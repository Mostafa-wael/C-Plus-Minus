%{
// include the y.tab.h file. This file is automatically generated by the compiler from the grammar rules in the .y file.  
#include "y.tab.h"
// a C function that is called by the parser whenever it encounters a syntax error. 
void yyerror (char *s); 
// called by the parser whenever it needs a token. This is where the lexical analyzer is called. 
int yylex();
int line=1;
%}
/* RegEx */
/*====================*/
DIGIT [0-9]
ALPHAB [a-z]
ALPHANUM [0-9a-zA-Z]
SPACES [ \r\t]
NEW_LINE \n
INLINE_COMMENT \/\/.*
MULTILINE_COMMENT \/\*.*\*\/
SPECIAL_CHARCHETES [*+-/;=%~&|^(){}:]
TRUE [tT]rue | 1 | [yY]es
FALSE [fF]alse | 0 | [nN]o
/* a directive that tells the compiler that the code below is the lexical analyzer.  */
/* The lexical analyzer is built by specifying regular expressions for each token.  */
/* first store the value of the token, and the second return its type */
/* e.g.: If you saw the string "print", return the token "print" */
%%
{ALPHAB}                 	       {yylval.TYPE_LETTER = yytext[0]; return IDENTIFIER;}
\-?{DIGIT}+                        {yylval.TYPE_INT = atoi(yytext); return NUMBER;}
\-?{DIGIT}*"."{DIGIT}+             {yylval.TYPE_FLOAT = atof(yytext); return FLOAT_NUMBER;}
\"[^\"]*\" 			               {yylval.TYPE_STR = strdup(yytext); return STRING; }


"print"				               {return PRINT;} /*print Command*/
"assert"                           {return ASSERT;} /*assert Command*/
"exit"				               {return EXIT;} /*exit Command*/

"const"                            {return CONST;} /*const Command*/

"int"                              {return INT_DATA_TYPE;} /*int Command*/
"float"                            {return FLOAT_DATA_TYPE;} /*float Command*/
"string"                           {return STRING_DATA_TYPE;} /*string Command*/
"bool"                             {return BOOL_DATA_TYPE;} /*bool Command*/
"void"                             {return VOID_DATA_TYPE;} /*void Command*/

"if"				               {return IF;} /*if Command*/
"else"				               {return ELSE;} /*else Command*/
"elif"				               {return ELIF;} /*elif Command*/

"switch"				           {return SWITCH;} /*switch Command*/
"case"				               {return CASE;} /*case Command*/
"default"				           {return DEFAULT;} /*default Command*/

"while"				               {return WHILE;} /*while Command*/
"for"				               {return FOR;} /*for Command*/
"repeat"				           {return REPEAT;} /*repeat Command*/
"until"				               {return UNTIL;} /*until Command*/
"break"				               {return BREAK;} /*break Command*/
"continue"				           {return CONTINUE;} /*continue Command*/

"return"				           {return RETURN;} /*return Command*/


"<<"                                {return SHL;} /*SHL Command*/
">>"                                {return SHR;} /*SHR Command*/

"=="                                {return EQ;} /*EQ Command*/
"!="                                {return NEQ;} /*NEQ Command*/
"<="                                {return LEQ;} /*LEQ Command*/
">="                                {return GEQ;} /*GEQ Command*/
"<"                                 {return LT;} /*LT Command*/
">"                                 {return GT;} /*GT Command*/

"&&"                                {return AND;} /*and Command*/
"||"                                {return OR;} /*or Command*/
"!"                                 {return NOT;} /*not Command*/

[tT]rue | 1 | [yY]es               {yylval.TYPE_BOOL=1; return TRUE;} /*true Command*/
[fF]alse | 0 | [nN]o               {yylval.TYPE_BOOL=0; return FALSE;} /*false Command*/

{NEW_LINE}                          line++; /*Ignore New Lines*/
{SPACES}                            ; /*Ignore White Spaces*/
{INLINE_COMMENT}                    ; /*Ignore Comments*/
{MULTILINE_COMMENT}                 ; /*Ignore Comments*/
{SPECIAL_CHARCHETES}                {return yytext[0];} /*Return the character*/
.                                   {ECHO; yyerror ("unexpected character");} /*Else, Error*/ 
%%
// C code
// The wrapper function yywrap() 
int yywrap (void) {return 1;}