%{
// include the y.tab.h file. This file is automatically generated by the compiler from the grammar rules in the .y file.  
#include "y.tab.h"
// a C function that is called by the parser whenever it encounters a syntax error. 
void yyerror (char *s); 
// called by the parser whenever it needs a token. This is where the lexical analyzer is called. 
int yylex();
int line=1;
%}
/* RegEx */
/*====================*/
DIGIT [0-9]
ALPHAB [a-z]
ALPHANUM [0-9a-zA-Z]
SPACES [ \r\t]
NEW_LINE \n
INLINE_COMMENT \/\/.*
MULTILINE_COMMENT \/\*.*\*\/
SPECIAL_CHARCHETES [*+-/;=%~&|^(){}:]
TRUE [tT]rue | 1 | [yY]es
FALSE [fF]alse | 0 | [nN]o
/* a directive that tells the compiler that the code below is the lexical analyzer.  */
/* The lexical analyzer is built by specifying regular expressions for each token.  */
/* first store the value of the token, and the second return its type */
/* e.g.: If you saw the string "print", return the token "print" */
/* ['"]({ALPHANUM})*['"]               {yylval.TYPE_STR = yytext; printf("%s\n", yytext);return string;} */
%%
{ALPHAB}                 	        {yylval.TYPE_LETTER = yytext[0]; return identifier;}
\-?{DIGIT}+                         {yylval.TYPE_INT = atoi(yytext); return number;}
\-?{DIGIT}*"."{DIGIT}+              {yylval.TYPE_FLOAT = atof(yytext); return float_number;}
\"[^\"]*\" 			                {yylval.TYPE_STR = strdup(yytext); return string; }


"print"				               {return PRINT;} /*print Command*/
"exit"				               {return EXIT;} /*exit Command*/

"if"				               {return IF;} /*if Command*/
"else"				               {return ELSE;} /*else Command*/
"elif"				               {return ELIF;} /*elif Command*/
"endif"				               {return ENDIF;} /*endif Command*/

"switch"				           {return SWITCH;} /*switch Command*/
"case"				               {return CASE;} /*case Command*/
"default"				           {return DEFAULT;} /*default Command*/
"endswitch"				           {return ENDSWITCH;} /*endswitch Command*/

"while"				               {return WHILE;} /*while Command*/
"for"				               {return FOR;} /*for Command*/
"break"				               {return BREAK;} /*break Command*/
"continue"				           {return CONTINUE;} /*continue Command*/

"function"				           {return FUNCTION;} /*function Command */
"return"				           {return RETURN;} /*return Command*/


"<<"                                {return SHL;} /*SHL Command*/
">>"                                {return SHR;} /*SHR Command*/

"=="                                {return EQ;} /*EQ Command*/
"!="                                {return NEQ;} /*NEQ Command*/
"<="                                {return LEQ;} /*LEQ Command*/
">="                                {return GEQ;} /*GEQ Command*/
"<"                                 {return LT;} /*LT Command*/
">"                                 {return GT;} /*GT Command*/

"&&"                                {return AND;} /*and Command*/
"||"                                {return OR;} /*or Command*/
"!"                                 {return NOT;} /*not Command*/

[tT]rue | 1 | [yY]es               {yylval.TYPE_BOOL=1; return true_command;} /*true Command*/
[fF]alse | 0 | [nN]o               {yylval.TYPE_BOOL=0; return false_command;} /*false Command*/

{NEW_LINE}                          line++; /*Ignore New Lines*/
{SPACES}                            ; /*Ignore White Spaces*/
{INLINE_COMMENT}                    ; /*Ignore Comments*/
{MULTILINE_COMMENT}                 ; /*Ignore Comments*/
{SPECIAL_CHARCHETES}                {return yytext[0];} /*Return the character*/
.                                   {ECHO; yyerror ("unexpected character");} /*Else, Error*/ 
%%
// C code
// The wrapper function yywrap() 
int yywrap (void) {return 1;}